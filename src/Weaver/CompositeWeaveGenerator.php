<?php


namespace Weaver;

use Zend\Code\Generator\ClassGenerator;

use Zend\Code\Generator\DocBlockGenerator;
use Zend\Code\Generator\MethodGenerator;
use Zend\Code\Generator\ParameterGenerator;
use Zend\Code\Generator\PropertyGenerator;
use Zend\Code\Reflection\MethodReflection;
use Zend\Code\Reflection\ClassReflection;


use Weaver\WeaveException;

class CompositeWeaveGenerator {

    /**
     * @var CompositeWeaveInfo
     */
    private $weaveInfo;

    /**
     * @var ClassReflection[]
     */
    private $compositeClassReflectionArray = [];
    
    private $containerClassReflection;
    

    /**
     * @param $sourceClass
     * @param $decoratorClass
     * @param $methodBindingArray
     * @internal param \Weaver\MethodBinding[] $methodBinding
     */
    function __construct(CompositeWeaveInfo $weaveInfo) {
        $this->containerClassReflection = new ClassReflection($weaveInfo->getDecoratorClass());
        $this->generator = new ClassGenerator();
        //$this->methodBindingArray = [];//$methodBindingArray;
        //$this->setupClassName();

        $this->weaveInfo = $weaveInfo;

        foreach ($weaveInfo->getComposites() as $composite) {
            $this->compositeClassReflectionArray[] = new ClassReflection($composite);
        }
    }

    function writeClass($outputDir) {

        $this->addPropertiesAndConstants($this->weaveInfo->getDecoratorClass());
        $this->addConstructorMethod();
        $this->addMethods();
        $this->addEncapsulatedMethods();


        $this->generator->setName($this->getFQCN());
        $this->saveFile($outputDir, $this->generator->generate());
    }


    /**
     * @param $savePath
     * @throws \RuntimeException
     */
    protected function saveFile($savePath, $text) {

        @mkdir($savePath, true);
        $filename = str_replace('\\', '/', $this->getFQCN().".php");

        $fileHeader = <<< END
<?php

//Auto-generated by Weaver - https://github.com/Danack/Weaver
//
//Do not be surprised if any changes to this file are over-written.

END;

        $text = $this->applyHacks($text);
        $written = file_put_contents($savePath.'/'.$filename, $fileHeader.$text);

        if ($written == false) {
            throw new \RuntimeException("Failed to write file $filename.");
        }
    }




//    /**
//     * @return null|MethodReflection
//     */
//    function addDecoratorMethods() {
//
//        $decoratorConstructorMethod = null;
//        $methods = $this->decoratorReflector->getMethods();
//
//        foreach ($methods as $method) {
//            $name = $method->getName();
//
//            if ($name == '__construct') {
//                $decoratorConstructorMethod = $method;
//                continue;
//            }
//
//            $parameters = $method->getParameters();
//
//            $generatedParameters = array();
//
//            foreach ($parameters as $reflectionParameter) {
//                $generatedParameters[] = ParameterGenerator::fromReflection($reflectionParameter);
//            }
//
//            $this->generator->addMethod(
//                            $name,
//                                $generatedParameters,
//                                MethodGenerator::FLAG_PUBLIC,
//                                $method->getBody(),
//                                $method->getDocBlock()
//            );
//        }
//
//        return $decoratorConstructorMethod;
//    }
//
//

    /*
    
          $factoryClosure = $this->generateFactoryClosure(
                               $originalSourceClass,
                               $constructorParameters,
                               $closureFactoryName,
                               $sourceConstructorMethod,
                               $decoratorConstructorMethod);
    
    */
    
//    /**
//     * @param $savePath
//     * @param $originalSourceClass
//     * @param $closureFactoryName
//     * @return null|string
//     */
//    function generateClass($savePath, $originalSourceClass, $closureFactoryName) {
//
//
//
//        $this->saveFile($savePath);
//
//  
//
//        //return $factoryClosure;
//        return null;
//    }

    function addConstructorForClassReflection(ClassReflection $reflection) {

        $params = [];
        

        return $params;
    }
    
    
    function addConstructorMethod() {
        /**
         * ParameterReflection[]
         */
        $constructorParametersGeneratorArray = [];

        $weaveConstructorBody = '';
        
        foreach ($this->compositeClassReflectionArray as $sourceReflector) {
            foreach ($sourceReflector->getMethods() as $methodReflection) {
                if (strcmp($methodReflection->getName(), '__construct') === 0) {
                    
                    $methodGenerator = MethodGenerator::fromReflection($methodReflection);
                    $modifiedConstructorName = 'construct_'.getClassName($sourceReflector->getName());
                    $methodGenerator->setName($modifiedConstructorName);
                    $this->generator->addMethodFromGenerator($methodGenerator);
                    $weaveConstructorBody .= "\t\t\$this->".$modifiedConstructorName.'(';

                    $separator = '';
                    $parameters = $methodReflection->getParameters();
                    foreach ($parameters as $reflectionParameter) {
                        $constructorParametersGeneratorArray[] = ParameterGenerator::fromReflection($reflectionParameter);
                        $weaveConstructorBody .= $separator.'$'.$reflectionParameter->getName();
                        $separator = ', ';
                    }
                    $weaveConstructorBody .= ");\n"; 
                }
            }
        }


        //TODO - this is a duplicate of the code above
        foreach ($this->containerClassReflection->getMethods() as $methodReflection) {
            if (strcmp($methodReflection->getName(), '__construct') === 0) {

                $methodGenerator = MethodGenerator::fromReflection($methodReflection);
                $modifiedConstructorName = 'construct_'.getClassName($methodReflection->getName());
                $methodGenerator->setName($modifiedConstructorName);
                $this->generator->addMethodFromGenerator($methodGenerator);
                $weaveConstructorBody .= "\t\t\$this->".$modifiedConstructorName.'(';

                $separator = '';
                $parameters = $methodReflection->getParameters();
                foreach ($parameters as $reflectionParameter) {
                    $constructorParametersGeneratorArray[] = ParameterGenerator::fromReflection($reflectionParameter);
                    $weaveConstructorBody .= $separator.'$'.$reflectionParameter->getName();
                    $separator = ', ';
                }
                $weaveConstructorBody .= ");\n";

                
            }
        }
        
        $this->generator->addMethod(
            '__construct',
            $constructorParametersGeneratorArray,
            MethodGenerator::FLAG_PUBLIC,
            $weaveConstructorBody
        );

        return [];
    }
    

    /**
     * @param MethodReflection $sourceConstructorMethod
     * @param MethodReflection $decoratorConstructorMethod
     * @return array
     */
    /*
    function addProxyConstructor(
        MethodReflection $sourceConstructorMethod = null,
        MethodReflection $decoratorConstructorMethod = null
    ) {

        $constructorBody = '';

        $generatedParameters = array();

        if ($sourceConstructorMethod != null) {
            $parameters = $sourceConstructorMethod->getParameters();

            $constructorBody .= 'parent::__construct(';

            $separator = '';

            foreach ($parameters as $reflectionParameter) {
                $generatedParameters[] = ParameterGenerator::fromReflection($reflectionParameter);
                $constructorBody .= $separator.'$'.$reflectionParameter->getName();
                $separator = ', ';
            }

            $constructorBody .= ");\n";
        }

        if ($decoratorConstructorMethod != null) {
            $parameters = $decoratorConstructorMethod->getParameters();
            foreach ($parameters as $reflectionParameter) {
                $generatedParameters[] = ParameterGenerator::fromReflection($reflectionParameter);
            }

            $constructorBody .= $decoratorConstructorMethod->getBody();
        }

        $this->generator->addMethod(
            '__construct',
            $generatedParameters,
            MethodGenerator::FLAG_PUBLIC,
            $constructorBody,
            ""
        );

        return $generatedParameters;
    }
*/

    /**
     * @param MethodReflection $method
     * @return bool|string
     */
    /*
    function generateProxyMethodBody(MethodReflection $method) {
        $name = $method->getName();

        $methodBinding = $this->getMethodBindingForMethod($name);

        if (!$methodBinding) {
            return false;
        }

        $newBody = '';
        
        $beforeFunction = $methodBinding->getBefore();
        
        if ($beforeFunction) {
            $newBody .= $beforeFunction."\n";
        }

        if ($methodBinding->getHasResult()) {
            $newBody .= '$result = parent::'.$method->getName()."(";
        }
        else {
            $newBody .= 'parent::'.$method->getName()."(";
        }
        $parameters = $method->getParameters();
        $separator = '';

        foreach ($parameters as $reflectionParameter) {
            $newBody .= $separator.'$'.$reflectionParameter->getName();
            $separator = ', ';
        }

        $newBody .= ");\n";

        $afterFunction = $methodBinding->getAfter();

        if ($afterFunction) {
            $newBody .= $afterFunction."\n\n";
        }

        if ($methodBinding->getHasResult()) {
            $newBody .= 'return $result;'."\n";
        }

        return $newBody;
    } */

    /**
     * @return string
     */
    function getClosureFactoryName() {
        $originalSourceReflection = $this->containerClassReflection;
        $closureFactoryName = '\\'.$this->containerClassReflection->getNamespaceName().'\Closure'.$originalSourceReflection->getShortName().'Factory';

        return $closureFactoryName;
    }

    /**
     * @return string
     */
    function getNamespaceName() {
        return $this->containerClassReflection->getNamespaceName();
    }

    function getProxiedName() {
        $proxiedName = $this->containerClassReflection->getShortName();
        foreach ($this->compositeClassReflectionArray as $sourceReflector) {
            $proxiedName .= "X".$sourceReflector->getShortName();
        }

        return $proxiedName;
    }

    /**
     * @param ClassReflection $sourceReflector
     */
    function addMethodFromReflection(ClassReflection $sourceReflector) {

        $methods = $sourceReflector->getMethods();

        foreach ($methods as $method) {
            $name = $method->getName();
            $methodGenerator = MethodGenerator::fromReflection($method);

            if ($name == '__construct') {
                //Constructors are handled separately.
                continue;
            }

            if (array_key_exists($name, $this->weaveInfo->getEncapsulateMethods()) == true) {
                $methodGenerator->setName($name.getClassName($sourceReflector->getName()));
            }

            $this->generator->addMethodFromGenerator($methodGenerator);
        }
    }

    /**
     * @return null|MethodReflection
     */
    function addMethods() {
        $this->addMethodFromReflection($this->containerClassReflection);
        foreach ($this->compositeClassReflectionArray as $sourceReflector) {
            $this->addMethodFromReflection($sourceReflector);
        }
    }

    /**
     * Adds the properties and constants from the decorating class to the
     * class being weaved.
     * @param $originalSourceClass
     */
    function addPropertiesAndConstants($originalSourceClass) {
        $this->addPropertiesAndConstantsForReflector($this->containerClassReflection);
        
        foreach ($this->compositeClassReflectionArray as $sourceReflector) {
            $this->addPropertiesAndConstantsForReflector($sourceReflector);
        }
    }

    function applyHacks($sourceCode) {
        $sourceCode = str_replace("(Intahwebz\\", "(\\Intahwebz\\", $sourceCode);
        return $sourceCode;
    }

    function generateFactoryClosure() {
    }


    /**
     * @param ClassReflection $reflector
     * @param $originalSourceClass
     */
    function addPropertiesAndConstantsForReflector(ClassReflection $reflector) {
        $constants = $reflector->getConstants();

        foreach ($constants as $name => $value) {
            $this->generator->addProperty($name, $value, PropertyGenerator::FLAG_CONSTANT);
        }

        $properties = $reflector->getProperties();

        foreach ($properties as $property) {
            $newProperty = PropertyGenerator::fromReflection($property);
            $this->generator->addPropertyFromGenerator($newProperty);
        }
    }

    function addEncapsulatedMethods() {
        foreach ($this->weaveInfo->getEncapsulateMethods() as $encapsulatedMethod => $resultType) {

            switch($resultType) {
                case('string'): {
                    $body = "\$result = '';\n";
                    foreach ($this->compositeClassReflectionArray as $compositeClassReflection) {
                        $body .= '    $result .= $this->'.$encapsulatedMethod.$compositeClassReflection->getShortName()."();\r\n";
                    }
                                    
                    break;
                }

                case('array'): {
                    $body = "\$result = [];\n";
                    foreach ($this->compositeClassReflectionArray as $compositeClassReflection) {
                        $body .= '    $result = array_merge($result, $this->'.$encapsulatedMethod.$compositeClassReflection->getShortName()."());\r\n";
                    }
                    break;
                }

                default:{
                    throw new WeaveException("Unknown resultType [$resultType]");
                    break;
                }
            }

            $body .= "\n";
            $body .= "return \$result;\n";
            
            $methodGenerator = new MethodGenerator(
                $encapsulatedMethod, //          $name = null, 
                [], 
                MethodGenerator::FLAG_PUBLIC, //$flags = self::FLAG_PUBLIC, 
                $body
                //$docBlock = null
            );

            $this->generator->addMethodFromGenerator($methodGenerator);
        }
    }
    

    /**
     * @return string
     */
    function getFQCN() {
        $namespace = $this->getNamespaceName();
        $classname = $this->getProxiedName();

        if (strlen($namespace)) {
            return $namespace.'\\'.$classname;
        }
        else {
            return $classname;
        }
    }
}

 